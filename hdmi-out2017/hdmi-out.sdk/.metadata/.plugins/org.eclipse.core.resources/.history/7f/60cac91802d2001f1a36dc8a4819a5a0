
#include "display_demo.h"
#include "display_ctrl/display_ctrl.h"
#include <stdio.h>
#include "xuartps.h"
#include "math.h"
#include <ctype.h>
#include <stdlib.h>
#include "xil_types.h"
#include "xil_cache.h"
#include "timer_ps/timer_ps.h"
#include "xparameters.h"
#include "xparameters.h"
#include "xgpio.h"
#include "xscugic.h"
#include "xil_exception.h"
#include "xil_printf.h"
#include "interrupts.h"
#include "hardware_init.h"
#include "define.h"
#include <stdio.h>
#include "xtime_l.h"
#include "display_demo.h"
#include "display_demo.h"
#include "display_ctrl/display_ctrl.h"
#include <stdio.h>
#include "xuartps.h"
#include "math.h"
#include <ctype.h>
#include <stdlib.h>
#include "xil_types.h"
#include "xil_cache.h"
#include "timer_ps/timer_ps.h"
#include "xparameters.h"
#include "sleep.h" // Include for delay function
#include <time.h>
#include "xtime_l.h"
#include "color.h"
#include <stdlib.h> // For rand()
#include <time.h>   // For seeding randomness


DisplayCtrl dispCtrl;
XAxiVdma vdma;

/*
 * Framebuffers for video data
 */
u8  frameBuf[DISPLAY_NUM_FRAMES][DEMO_MAX_FRAME] __attribute__((aligned(0x20)));
u8 *pFrames[DISPLAY_NUM_FRAMES]; //array of pointers to the frame buffers


#define GRID_X_START 200                     // Starting X position of the grid
#define GRID_Y_START 50                      // Starting Y position of the grid
#define BLOCK_SIZE 20                        // Each block is 20x20 pixels
#define NUM_COLUMNS 10                       // 10 columns in the grid
#define NUM_ROWS 20                          // 20 rows in the grid
#define GRID_WIDTH (NUM_COLUMNS * BLOCK_SIZE) // Total grid width: 200 pixels
#define GRID_HEIGHT (NUM_ROWS * BLOCK_SIZE)   // Total grid height: 400 pixels

#define SCORE_BOX_X 50
#define SCORE_BOX_Y 50
#define SCORE_BOX_WIDTH 100
#define SCORE_BOX_HEIGHT 100

#define NEXT_BOX_X 550
#define NEXT_BOX_Y 50
#define NEXT_BOX_WIDTH 100
#define NEXT_BOX_HEIGHT 100
#define GRID_COLUMNS 10
#define GRID_ROWS 20
void DemoFillWhite(u8 *frame, u32 width, u32 height, u32 stride);
void DemoFillBlack(u8 *frame, u32 width, u32 height, u32 stride);
void FallShape(u8 *frame, u32 width, u32 height, u32 stride,
               void (*DrawShape)(u8*, u32, u32, u32, u32, u8, u8, u8),
               u32 xStart, u32 blockSize, u8 red, u8 green, u8 blue);
void DrawShapeI(u8 *frame, u32 xStart, u32 yStart, u32 blockSize, u32 stride, u8 red, u8 green, u8 blue);
void DrawShapeO(u8 *frame, u32 xStart, u32 yStart, u32 blockSize, u32 stride, u8 red, u8 green, u8 blue);
void DrawShapeT(u8 *frame, u32 xStart, u32 yStart, u32 blockSize, u32 stride, u8 red, u8 green, u8 blue);

// Define the normal and fast falling intervals
double normal_fall_interval = 0.3; // Normal fall interval in seconds
double fast_fall_interval = 0.1;  // Fast fall interval in seconds
double current_fall_interval;     // Dynamic fall interval

int gameOver = 0; // 0 for active, 1 for game over
int score = 0; // Initialize score

#define NUM_SHAPES 7 // Total number of Tetris shapes

int currentShape = 0; // Active shape
int nextShape = 0;    // Next shape to display in the "Next Box"

// Snap a position to the nearest grid line
u32 SnapToGrid(u32 position, u32 gridStart, u32 blockSize) {
    return gridStart + ((position - gridStart) / blockSize) * blockSize;
}
// Define shape types
// Define shape types
#define SHAPE_I 0
#define SHAPE_O 1
#define SHAPE_T 2
#define SHAPE_S 3
#define SHAPE_Z 4
#define SHAPE_L 5
#define SHAPE_J 6


// Define RGB values for each block
#define COLOR_I 0, 0, 255        // Blue
#define COLOR_O 255, 255, 0      // Yellow
#define COLOR_T 128, 0, 128      // Purple
#define COLOR_S 0, 255, 0        // Green
#define COLOR_Z 255, 0, 0        // Red
#define COLOR_L 255, 165, 0      // Orange
#define COLOR_J 0, 128, 255      // Light Blue

//int currentShape = SHAPE_I; // Start with the "I" block
// Define a counter to cycle through the shapes
int shapeIndex = 0; // Initialize the shape index

void SpawnNextBlock(u32 *blockX, u32 *blockY, int *currentShape) {
    *currentShape = (*currentShape + 1) % NUM_SHAPES; // Cycle through shapes
    *blockX = GRID_X_START + (GRID_WIDTH / 2) - BLOCK_SIZE; // Center the block
    *blockY = GRID_Y_START; // Reset to the top of the grid
    xil_printf("Spawned block: %d\r\n", *currentShape);
}
u8 gridColors[GRID_ROWS][GRID_COLUMNS][3] = {{{0}}}; // Each cell stores RGB values


int grid[GRID_ROWS][GRID_COLUMNS] = {0}; // Initialize the grid with all cells empty

// Function to check if the block can move down
int CanMoveDown(u32 blockX, u32 blockY) {
    int colStart = (blockX - GRID_X_START) / BLOCK_SIZE;
    int rowStart = (blockY - GRID_Y_START) / BLOCK_SIZE;

    if (currentShape == SHAPE_I) {
        for (int i = 0; i < 4; i++) {
            if (rowStart + i + 1 >= NUM_ROWS || grid[rowStart + i + 1][colStart] == 1) {
                return 0;
            }
        }
    } else if (currentShape == SHAPE_O) {
        for (int i = 0; i < 2; i++) {
            for (int j = 0; j < 2; j++) {
                if (rowStart + i + 1 >= NUM_ROWS || grid[rowStart + i + 1][colStart + j] == 1) {
                    return 0;
                }
            }
        }
    } else if (currentShape == SHAPE_T) {
        if (rowStart + 1 >= NUM_ROWS ||
            grid[rowStart + 1][colStart] == 1 ||
            grid[rowStart + 1][colStart + 1] == 1 ||
            grid[rowStart + 1][colStart + 2] == 1) {
            return 0;
        }
    } else if (currentShape == SHAPE_S) {
        // Check top row of S shape
        if (rowStart + 1 >= GRID_ROWS ||  // Check grid boundary
            grid[rowStart + 1][colStart + 1] == 1 ||   // Top-middle block
            grid[rowStart + 1][colStart + 2] == 1) {   // Top-right block
            return 0; // Collision detected
        }
        // Check bottom row of S shape
        if (rowStart + 2 >= GRID_ROWS ||  // Check grid boundary
            grid[rowStart + 2][colStart] == 1 ||       // Bottom-left block
            grid[rowStart + 2][colStart + 1] == 1) {   // Bottom-middle block
            return 0; // Collision detected
        }


    } else  if (currentShape == SHAPE_Z) {
        // Check top row of Z shape
        if (rowStart + 1 >= NUM_ROWS ||
            grid[rowStart + 1][colStart] == 1 ||       // Top-left block
            grid[rowStart + 2][colStart + 1] == 1) {  // Bottom-left block
            return 0;
        }
        // Check bottom row of Z shape
        if (rowStart + 2 >= NUM_ROWS ||
            grid[rowStart + 2][colStart + 1] == 1 ||  // Bottom-middle block
            grid[rowStart + 2][colStart + 2] == 1) {  // Bottom-right block
            return 0;
        }
    } else if (currentShape == SHAPE_L) {
        // Check vertical bar (leftmost part of the L block)
        for (int i = 0; i < 2; i++) { // Iterate through the vertical bar
            if (rowStart + i + 1 >= GRID_ROWS ||  // Check grid boundary
                grid[rowStart + i + 1][colStart] == 1) { // Collision detected below
                return 0;
            }
        }

        // Check horizontal bar (bottom row of the L block)
        for (int j = 1; j <= 2; j++) { // Check the bottom-middle and bottom-right parts
            if (rowStart + 2 >= GRID_ROWS ||  // Check grid boundary
                grid[rowStart + 2][colStart + j] == 1) { // Collision detected below
                return 0;
            }
        }
    } else if (currentShape == SHAPE_J) {
        // Check vertical bar (rightmost part of the J block)
        for (int i = 0; i < 2; i++) {
            if (rowStart + i + 1 >= GRID_ROWS ||  // Check grid boundary
                grid[rowStart + i + 1][colStart + 2] == 1) { // Collision below the vertical bar
                return 0; // Collision detected
            }
        }

        // Check horizontal bar (bottom row of the J block)
        for (int j = 0; j < 3; j++) {
            if (rowStart + 2 >= GRID_ROWS ||  // Check grid boundary
                grid[rowStart + 2][colStart + j] == 1) { // Collision below horizontal bar
                return 0; // Collision detected
            }
        }
    }




    return 1;
}

// Function to mark the block's position on the grid
void MarkBlockOnGrid(u32 blockX, u32 blockY) {
    int colStart = (blockX - GRID_X_START) / BLOCK_SIZE;
    int rowStart = (blockY - GRID_Y_START) / BLOCK_SIZE;

    if (currentShape == SHAPE_I) {
        for (int i = 0; i < 4; i++) {
            grid[rowStart + i][colStart] = 1;
            gridColors[rowStart + i][colStart][0] = 0;   // Red
            gridColors[rowStart + i][colStart][1] = 255; // Green
            gridColors[rowStart + i][colStart][2] = 255; // Blue
        }
    } else if (currentShape == SHAPE_O) {
        for (int i = 0; i < 2; i++) {
            for (int j = 0; j < 2; j++) {
                grid[rowStart + i][colStart + j] = 1;
                gridColors[rowStart + i][colStart + j][0] = 255;  // Red
                gridColors[rowStart + i][colStart + j][1] = 255;  // Green
                gridColors[rowStart + i][colStart + j][2] = 0;    // Blue
            }
        }
    } else if (currentShape == SHAPE_T) {
        for (int j = 0; j < 3; j++) {
            grid[rowStart][colStart + j] = 1;
            gridColors[rowStart][colStart + j][0] = 128;  // Red
            gridColors[rowStart][colStart + j][1] = 0;    // Green
            gridColors[rowStart][colStart + j][2] = 128;  // Blue
        }
        grid[rowStart - 1][colStart + 1] = 1;
        gridColors[rowStart - 1][colStart + 1][0] = 128;  // Red
        gridColors[rowStart - 1][colStart + 1][1] = 0;    // Green
        gridColors[rowStart - 1][colStart + 1][2] = 128;  // Blue
    } else if (currentShape == SHAPE_S) {
        grid[rowStart][colStart + 1] = 1;
        gridColors[rowStart][colStart + 1][0] = 0;   // Red
        gridColors[rowStart][colStart + 1][1] = 255; // Green
        gridColors[rowStart][colStart + 1][2] = 0;   // Blue

        grid[rowStart][colStart + 2] = 1;
        gridColors[rowStart][colStart + 2][0] = 0;   // Red
        gridColors[rowStart][colStart + 2][1] = 255; // Green
        gridColors[rowStart][colStart + 2][2] = 0;   // Blue

        grid[rowStart + 1][colStart] = 1;
        gridColors[rowStart + 1][colStart][0] = 0;   // Red
        gridColors[rowStart + 1][colStart][1] = 255; // Green
        gridColors[rowStart + 1][colStart][2] = 0;   // Blue

        grid[rowStart + 1][colStart + 1] = 1;
        gridColors[rowStart + 1][colStart + 1][0] = 0;   // Red
        gridColors[rowStart + 1][colStart + 1][1] = 255; // Green
        gridColors[rowStart + 1][colStart + 1][2] = 0;   // Blue
    } else if (currentShape == SHAPE_Z) {
        grid[rowStart][colStart] = 1;
        gridColors[rowStart][colStart][0] = 255;  // Red
        gridColors[rowStart][colStart][1] = 0;    // Green
        gridColors[rowStart][colStart][2] = 0;    // Blue

        grid[rowStart][colStart + 1] = 1;
        gridColors[rowStart][colStart + 1][0] = 255;  // Red
        gridColors[rowStart][colStart + 1][1] = 0;    // Green
        gridColors[rowStart][colStart + 1][2] = 0;    // Blue

        grid[rowStart + 1][colStart + 1] = 1;
        gridColors[rowStart + 1][colStart + 1][0] = 255;  // Red
        gridColors[rowStart + 1][colStart + 1][1] = 0;    // Green
        gridColors[rowStart + 1][colStart + 1][2] = 0;    // Blue

        grid[rowStart + 1][colStart + 2] = 1;
        gridColors[rowStart + 1][colStart + 2][0] = 255;  // Red
        gridColors[rowStart + 1][colStart + 2][1] = 0;    // Green
        gridColors[rowStart + 1][colStart + 2][2] = 0;    // Blue
    } else if (currentShape == SHAPE_L) {
        for (int i = 0; i < 2; i++) {
            grid[rowStart + i][colStart] = 1;
            gridColors[rowStart + i][colStart][0] = 255;  // Red
            gridColors[rowStart + i][colStart][1] = 165;  // Green
            gridColors[rowStart + i][colStart][2] = 0;    // Blue (Orange)
        }
        for (int j = 1; j <= 2; j++) {
            grid[rowStart + 1][colStart + j] = 1;
            gridColors[rowStart + 1][colStart + j][0] = 255;  // Red
            gridColors[rowStart + 1][colStart + j][1] = 165;  // Green
            gridColors[rowStart + 1][colStart + j][2] = 0;    // Blue (Orange)
        }
    } else if (currentShape == SHAPE_J) {
        for (int i = 0; i < 2; i++) {
            grid[rowStart + i][colStart + 2] = 1;
            gridColors[rowStart + i][colStart + 2][0] = 0;   // Red
            gridColors[rowStart + i][colStart + 2][1] = 0;   // Green
            gridColors[rowStart + i][colStart + 2][2] = 255; // Blue
        }
        for (int j = 0; j < 2; j++) {
            grid[rowStart + 1][colStart + j] = 1;
            gridColors[rowStart + 1][colStart + j][0] = 0;   // Red
            gridColors[rowStart + 1][colStart + j][1] = 0;   // Green
            gridColors[rowStart + 1][colStart + j][2] = 255; // Blue
        }
    }
}
void DrawActiveBlock(u32 blockX, u32 blockY) {
    switch (currentShape) {
        case SHAPE_I:
            DrawShapeI(dispCtrl.framePtr[dispCtrl.curFrame], blockX, blockY, BLOCK_SIZE, dispCtrl.stride, COLOR_I);
            break;
        case SHAPE_O:
            DrawShapeO(dispCtrl.framePtr[dispCtrl.curFrame], blockX, blockY, BLOCK_SIZE, dispCtrl.stride, COLOR_O);
            break;
        case SHAPE_T:
            DrawShapeT(dispCtrl.framePtr[dispCtrl.curFrame], blockX, blockY, BLOCK_SIZE, dispCtrl.stride, COLOR_T);
            break;
        case SHAPE_S:
            DrawShapeS(dispCtrl.framePtr[dispCtrl.curFrame], blockX, blockY, BLOCK_SIZE, dispCtrl.stride, COLOR_S);
            break;
        case SHAPE_Z:
            DrawShapeZ(dispCtrl.framePtr[dispCtrl.curFrame], blockX, blockY, BLOCK_SIZE, dispCtrl.stride, COLOR_Z);
            break;
        case SHAPE_L:
            DrawShapeL(dispCtrl.framePtr[dispCtrl.curFrame], blockX, blockY, BLOCK_SIZE, dispCtrl.stride, COLOR_L);
            break;
        case SHAPE_J:
            DrawShapeJ(dispCtrl.framePtr[dispCtrl.curFrame], blockX, blockY, BLOCK_SIZE, dispCtrl.stride, COLOR_J);
            break;
        default:
            xil_printf("Unknown shape: %d\r\n", currentShape);
            break;
    }
}


// Reset block position after landing
void ResetBlock(u32 *blockX, u32 *blockY, int *rotationI, int *isFalling) {
    *blockX = GRID_X_START + (GRID_WIDTH / 2) - BLOCK_SIZE * 2; // Center block
    *blockY = GRID_Y_START; // Reset to top of the grid
    *rotationI = 0;         // Reset rotation
    *isFalling = 1;         // Enable falling for the next block

    // Check for game over (if the top row is occupied)
    int colStart = (*blockX - GRID_X_START) / BLOCK_SIZE;
    for (int i = 0; i < 4; i++) {
        if (grid[0][colStart + i] == 1) {
            xil_printf("Game Over! Press BTN2 to restart.\r\n");
            gameOver = 1; // Set game over
            *isFalling = 0; // Stop block falling
            break;
        }
    }
}
void DrawGridLines(u32 x, u32 y) {
    // Draw the grid lines around the cleared block
    DrawRectangle(dispCtrl.framePtr[dispCtrl.curFrame], x, y, BLOCK_SIZE, 1, dispCtrl.stride, 255, 255, 255); // Horizontal top line
    DrawRectangle(dispCtrl.framePtr[dispCtrl.curFrame], x, y + BLOCK_SIZE - 1, BLOCK_SIZE, 1, dispCtrl.stride, 255, 255, 255); // Horizontal bottom line
    DrawRectangle(dispCtrl.framePtr[dispCtrl.curFrame], x, y, 1, BLOCK_SIZE, dispCtrl.stride, 255, 255, 255); // Vertical left line
    DrawRectangle(dispCtrl.framePtr[dispCtrl.curFrame], x + BLOCK_SIZE - 1, y, 1, BLOCK_SIZE, dispCtrl.stride, 255, 255, 255); // Vertical right line
}


void ClearBlockTrail(u32 blockX, u32 blockY) {
    int colStart = (blockX - GRID_X_START) / BLOCK_SIZE;
    int rowStart = (blockY - GRID_Y_START) / BLOCK_SIZE;

    if (currentShape == SHAPE_I) {
        for (int i = 0; i < 4; i++) {
            int x = GRID_X_START + colStart * BLOCK_SIZE;
            int y = GRID_Y_START + (rowStart + i) * BLOCK_SIZE;

            DrawRectangle(dispCtrl.framePtr[dispCtrl.curFrame], x, y, BLOCK_SIZE, BLOCK_SIZE, dispCtrl.stride, 0, 0, 0);
            DrawGridLines(x, y);
        }
    } else if (currentShape == SHAPE_O) {
        for (int i = 0; i < 2; i++) {
            for (int j = 0; j < 2; j++) {
                int x = GRID_X_START + (colStart + j) * BLOCK_SIZE;
                int y = GRID_Y_START + (rowStart + i) * BLOCK_SIZE;

                DrawRectangle(dispCtrl.framePtr[dispCtrl.curFrame], x, y, BLOCK_SIZE, BLOCK_SIZE, dispCtrl.stride, 0, 0, 0);
                DrawGridLines(x, y);
            }
        }
    } else if (currentShape == SHAPE_T) {
        for (int j = 0; j < 3; j++) {
            int x = GRID_X_START + (colStart + j) * BLOCK_SIZE;
            int y = GRID_Y_START + rowStart * BLOCK_SIZE;

            DrawRectangle(dispCtrl.framePtr[dispCtrl.curFrame], x, y, BLOCK_SIZE, BLOCK_SIZE, dispCtrl.stride, 0, 0, 0);
            DrawGridLines(x, y);
        }
        int x = GRID_X_START + (colStart + 1) * BLOCK_SIZE;
        int y = GRID_Y_START + (rowStart - 1) * BLOCK_SIZE;

        DrawRectangle(dispCtrl.framePtr[dispCtrl.curFrame], x, y, BLOCK_SIZE, BLOCK_SIZE, dispCtrl.stride, 0, 0, 0);
        DrawGridLines(x, y);
    } else if (currentShape == SHAPE_S) {
        int x, y;

        x = GRID_X_START + (colStart + 1) * BLOCK_SIZE;
        y = GRID_Y_START + rowStart * BLOCK_SIZE;
        DrawRectangle(dispCtrl.framePtr[dispCtrl.curFrame], x, y, BLOCK_SIZE, BLOCK_SIZE, dispCtrl.stride, 0, 0, 0);
        DrawGridLines(x, y);

        x = GRID_X_START + (colStart + 2) * BLOCK_SIZE;
        y = GRID_Y_START + rowStart * BLOCK_SIZE;
        DrawRectangle(dispCtrl.framePtr[dispCtrl.curFrame], x, y, BLOCK_SIZE, BLOCK_SIZE, dispCtrl.stride, 0, 0, 0);
        DrawGridLines(x, y);

        x = GRID_X_START + colStart * BLOCK_SIZE;
        y = GRID_Y_START + (rowStart + 1) * BLOCK_SIZE;
        DrawRectangle(dispCtrl.framePtr[dispCtrl.curFrame], x, y, BLOCK_SIZE, BLOCK_SIZE, dispCtrl.stride, 0, 0, 0);
        DrawGridLines(x, y);

        x = GRID_X_START + (colStart + 1) * BLOCK_SIZE;
        y = GRID_Y_START + (rowStart + 1) * BLOCK_SIZE;
        DrawRectangle(dispCtrl.framePtr[dispCtrl.curFrame], x, y, BLOCK_SIZE, BLOCK_SIZE, dispCtrl.stride, 0, 0, 0);
        DrawGridLines(x, y);
    } else if (currentShape == SHAPE_Z) {
        int x, y;

        x = GRID_X_START + colStart * BLOCK_SIZE;
        y = GRID_Y_START + rowStart * BLOCK_SIZE;
        DrawRectangle(dispCtrl.framePtr[dispCtrl.curFrame], x, y, BLOCK_SIZE, BLOCK_SIZE, dispCtrl.stride, 0, 0, 0);
        DrawGridLines(x, y);

        x = GRID_X_START + (colStart + 1) * BLOCK_SIZE;
        y = GRID_Y_START + rowStart * BLOCK_SIZE;
        DrawRectangle(dispCtrl.framePtr[dispCtrl.curFrame], x, y, BLOCK_SIZE, BLOCK_SIZE, dispCtrl.stride, 0, 0, 0);
        DrawGridLines(x, y);

        x = GRID_X_START + (colStart + 1) * BLOCK_SIZE;
        y = GRID_Y_START + (rowStart + 1) * BLOCK_SIZE;
        DrawRectangle(dispCtrl.framePtr[dispCtrl.curFrame], x, y, BLOCK_SIZE, BLOCK_SIZE, dispCtrl.stride, 0, 0, 0);
        DrawGridLines(x, y);

        x = GRID_X_START + (colStart + 2) * BLOCK_SIZE;
        y = GRID_Y_START + (rowStart + 1) * BLOCK_SIZE;
        DrawRectangle(dispCtrl.framePtr[dispCtrl.curFrame], x, y, BLOCK_SIZE, BLOCK_SIZE, dispCtrl.stride, 0, 0, 0);
        DrawGridLines(x, y);
    } else if (currentShape == SHAPE_L) {
        for (int i = 0; i < 2; i++) {
            int x = GRID_X_START + colStart * BLOCK_SIZE;
            int y = GRID_Y_START + (rowStart + i) * BLOCK_SIZE;

            DrawRectangle(dispCtrl.framePtr[dispCtrl.curFrame], x, y, BLOCK_SIZE, BLOCK_SIZE, dispCtrl.stride, 0, 0, 0);
            DrawGridLines(x, y);
        }
        for (int j = 1; j < 3; j++) {
            int x = GRID_X_START + (colStart + j) * BLOCK_SIZE;
            int y = GRID_Y_START + (rowStart + 1) * BLOCK_SIZE;

            DrawRectangle(dispCtrl.framePtr[dispCtrl.curFrame], x, y, BLOCK_SIZE, BLOCK_SIZE, dispCtrl.stride, 0, 0, 0);
            DrawGridLines(x, y);
        }
    } else if (currentShape == SHAPE_J) {
        for (int i = 0; i < 2; i++) {
            int x = GRID_X_START + (colStart + 2) * BLOCK_SIZE;
            int y = GRID_Y_START + (rowStart + i) * BLOCK_SIZE;

            DrawRectangle(dispCtrl.framePtr[dispCtrl.curFrame], x, y, BLOCK_SIZE, BLOCK_SIZE, dispCtrl.stride, 0, 0, 0);
            DrawGridLines(x, y);
        }
        for (int j = 0; j < 2; j++) {
            int x = GRID_X_START + (colStart + j) * BLOCK_SIZE;
            int y = GRID_Y_START + (rowStart + 1) * BLOCK_SIZE;

            DrawRectangle(dispCtrl.framePtr[dispCtrl.curFrame], x, y, BLOCK_SIZE, BLOCK_SIZE, dispCtrl.stride, 0, 0, 0);
            DrawGridLines(x, y);
        }
    }
}


void MarkLandedBlocks(u32 blockX, u32 blockY) {
    int colStart = (blockX - GRID_X_START) / BLOCK_SIZE;
    int rowStart = (blockY - GRID_Y_START) / BLOCK_SIZE;

    if (currentShape == SHAPE_I) {
        for (int i = 0; i < 4; i++) {
            DrawBlock(dispCtrl.framePtr[dispCtrl.curFrame],
                      GRID_X_START + colStart * BLOCK_SIZE,
                      GRID_Y_START + (rowStart + i) * BLOCK_SIZE,
                      BLOCK_SIZE, dispCtrl.stride, COLOR_I);
        }
    } else if (currentShape == SHAPE_O) {
        for (int i = 0; i < 2; i++) {
            for (int j = 0; j < 2; j++) {
                DrawBlock(dispCtrl.framePtr[dispCtrl.curFrame],
                          GRID_X_START + (colStart + j) * BLOCK_SIZE,
                          GRID_Y_START + (rowStart + i) * BLOCK_SIZE,
                          BLOCK_SIZE, dispCtrl.stride, COLOR_O);
            }
        }
    } else if (currentShape == SHAPE_T) {
        for (int j = 0; j < 3; j++) {
            DrawBlock(dispCtrl.framePtr[dispCtrl.curFrame],
                      GRID_X_START + (colStart + j) * BLOCK_SIZE,
                      GRID_Y_START + rowStart * BLOCK_SIZE,
                      BLOCK_SIZE, dispCtrl.stride, COLOR_T);
        }
        DrawBlock(dispCtrl.framePtr[dispCtrl.curFrame],
                  GRID_X_START + (colStart + 1) * BLOCK_SIZE,
                  GRID_Y_START + (rowStart - 1) * BLOCK_SIZE,
                  BLOCK_SIZE, dispCtrl.stride, COLOR_T);
    } else if (currentShape == SHAPE_S) {
        DrawBlock(dispCtrl.framePtr[dispCtrl.curFrame],
                  GRID_X_START + (colStart + 1) * BLOCK_SIZE,
                  GRID_Y_START + rowStart * BLOCK_SIZE,
                  BLOCK_SIZE, dispCtrl.stride, COLOR_S); // Top-right
        DrawBlock(dispCtrl.framePtr[dispCtrl.curFrame],
                  GRID_X_START + (colStart + 2) * BLOCK_SIZE,
                  GRID_Y_START + rowStart * BLOCK_SIZE,
                  BLOCK_SIZE, dispCtrl.stride, COLOR_S); // Top-left
        DrawBlock(dispCtrl.framePtr[dispCtrl.curFrame],
                  GRID_X_START + colStart * BLOCK_SIZE,
                  GRID_Y_START + (rowStart + 1) * BLOCK_SIZE,
                  BLOCK_SIZE, dispCtrl.stride, COLOR_S); // Bottom-left
        DrawBlock(dispCtrl.framePtr[dispCtrl.curFrame],
                  GRID_X_START + (colStart + 1) * BLOCK_SIZE,
                  GRID_Y_START + (rowStart + 1) * BLOCK_SIZE,
                  BLOCK_SIZE, dispCtrl.stride, COLOR_S); // Bottom-right
    } else if (currentShape == SHAPE_Z) {
        DrawBlock(dispCtrl.framePtr[dispCtrl.curFrame],
                  GRID_X_START + colStart * BLOCK_SIZE,
                  GRID_Y_START + rowStart * BLOCK_SIZE,
                  BLOCK_SIZE, dispCtrl.stride, COLOR_Z); // Top-left
        DrawBlock(dispCtrl.framePtr[dispCtrl.curFrame],
                  GRID_X_START + (colStart + 1) * BLOCK_SIZE,
                  GRID_Y_START + rowStart * BLOCK_SIZE,
                  BLOCK_SIZE, dispCtrl.stride, COLOR_Z); // Top-middle
        DrawBlock(dispCtrl.framePtr[dispCtrl.curFrame],
                  GRID_X_START + (colStart + 1) * BLOCK_SIZE,
                  GRID_Y_START + (rowStart + 1) * BLOCK_SIZE,
                  BLOCK_SIZE, dispCtrl.stride, COLOR_Z); // Bottom-middle
        DrawBlock(dispCtrl.framePtr[dispCtrl.curFrame],
                  GRID_X_START + (colStart + 2) * BLOCK_SIZE,
                  GRID_Y_START + (rowStart + 1) * BLOCK_SIZE,
                  BLOCK_SIZE, dispCtrl.stride, COLOR_Z); // Bottom-right
    } else if (currentShape == SHAPE_L) {
        DrawBlock(dispCtrl.framePtr[dispCtrl.curFrame],
                  GRID_X_START + colStart * BLOCK_SIZE,
                  GRID_Y_START + rowStart * BLOCK_SIZE,
                  BLOCK_SIZE, dispCtrl.stride, COLOR_L); // Top vertical block
        DrawBlock(dispCtrl.framePtr[dispCtrl.curFrame],
                  GRID_X_START + colStart * BLOCK_SIZE,
                  GRID_Y_START + (rowStart + 1) * BLOCK_SIZE,
                  BLOCK_SIZE, dispCtrl.stride, COLOR_L); // Bottom vertical block
        DrawBlock(dispCtrl.framePtr[dispCtrl.curFrame],
                  GRID_X_START + (colStart + 1) * BLOCK_SIZE,
                  GRID_Y_START + (rowStart + 1) * BLOCK_SIZE,
                  BLOCK_SIZE, dispCtrl.stride, COLOR_L); // Bottom-middle horizontal block
        DrawBlock(dispCtrl.framePtr[dispCtrl.curFrame],
                  GRID_X_START + (colStart + 2) * BLOCK_SIZE,
                  GRID_Y_START + (rowStart + 1) * BLOCK_SIZE,
                  BLOCK_SIZE, dispCtrl.stride, COLOR_L); // Bottom-right horizontal block
    }   else if (currentShape == SHAPE_J) {
        DrawBlock(dispCtrl.framePtr[dispCtrl.curFrame],
                  GRID_X_START + (colStart + 2) * BLOCK_SIZE,
                  GRID_Y_START + rowStart * BLOCK_SIZE,
                  BLOCK_SIZE, dispCtrl.stride, COLOR_J); // Top vertical block
        DrawBlock(dispCtrl.framePtr[dispCtrl.curFrame],
                  GRID_X_START + (colStart + 2) * BLOCK_SIZE,
                  GRID_Y_START + (rowStart + 1) * BLOCK_SIZE,
                  BLOCK_SIZE, dispCtrl.stride, COLOR_J); // Bottom vertical block
        DrawBlock(dispCtrl.framePtr[dispCtrl.curFrame],
                  GRID_X_START + (colStart + 1) * BLOCK_SIZE,
                  GRID_Y_START + (rowStart + 1) * BLOCK_SIZE,
                  BLOCK_SIZE, dispCtrl.stride, COLOR_J); // Bottom-middle horizontal block
        DrawBlock(dispCtrl.framePtr[dispCtrl.curFrame],
                  GRID_X_START + colStart * BLOCK_SIZE,
                  GRID_Y_START + (rowStart + 1) * BLOCK_SIZE,
                  BLOCK_SIZE, dispCtrl.stride, COLOR_J); // Bottom-left horizontal block
    }


}

void ClearFullRows() {
    for (int row = 0; row < GRID_ROWS; row++) {
        int isFull = 1;

        // Check if the row is fully occupied
        for (int col = 0; col < GRID_COLUMNS; col++) {
            if (grid[row][col] == 0) {
                isFull = 0;
                break;
            }
        }

        // If the row is full, clear it and make rows above fall
        if (isFull) {
            xil_printf("Clearing row %d and shifting rows above.\n", row);

            // Update the score
            score += 100;

            // Shift all rows above down by one
            for (int r = row; r > 0; r--) {
                for (int col = 0; col < GRID_COLUMNS; col++) {
                    grid[r][col] = grid[r - 1][col];
                    gridColors[r][col][0] = gridColors[r - 1][col][0];
                    gridColors[r][col][1] = gridColors[r - 1][col][1];
                    gridColors[r][col][2] = gridColors[r - 1][col][2];
                }
            }

            // Clear the top row in the grid and colors
            for (int col = 0; col < GRID_COLUMNS; col++) {
                grid[0][col] = 0;
                gridColors[0][col][0] = 0;
                gridColors[0][col][1] = 0;
                gridColors[0][col][2] = 0;
            }

            // Redraw all blocks after shifting
            RedrawGridBlocks();

            // Check the same row again
            row--;
        }
    }

    // Redraw the grid lines
    DrawGrid(dispCtrl.framePtr[dispCtrl.curFrame], GRID_X_START, GRID_Y_START, GRID_WIDTH, GRID_HEIGHT, dispCtrl.stride, BLOCK_SIZE);

    // Flush the cache to ensure changes are reflected
    Xil_DCacheFlushRange((unsigned int)dispCtrl.framePtr[dispCtrl.curFrame], dispCtrl.vMode.height * dispCtrl.stride);
}



void RedrawGridBlocks() {
    for (int row = 0; row < GRID_ROWS; row++) {
        for (int col = 0; col < GRID_COLUMNS; col++) {
            if (grid[row][col] == 1) {
                DrawBlock(dispCtrl.framePtr[dispCtrl.curFrame],
                          GRID_X_START + col * BLOCK_SIZE,
                          GRID_Y_START + row * BLOCK_SIZE,
                          BLOCK_SIZE, dispCtrl.stride,
                          gridColors[row][col][0],  // Red
                          gridColors[row][col][1],  // Green
                          gridColors[row][col][2]   // Blue
                );
            } else {
                // Clear empty cells
                DrawRectangle(dispCtrl.framePtr[dispCtrl.curFrame],
                              GRID_X_START + col * BLOCK_SIZE,
                              GRID_Y_START + row * BLOCK_SIZE,
                              BLOCK_SIZE, BLOCK_SIZE, dispCtrl.stride, 0, 0, 0);
            }
        }
    }
}


void ClearRowVisual(int row) {
    // Calculate the y-coordinate of the row
    u32 yStart = GRID_Y_START + row * BLOCK_SIZE;

    // Clear the row visually by filling it with the grid background color (black)
    DrawRectangle(dispCtrl.framePtr[dispCtrl.curFrame], GRID_X_START, yStart,
                  GRID_WIDTH, BLOCK_SIZE, dispCtrl.stride, 0, 0, 0); // Black background

    // Redraw the grid lines over the cleared area
    for (u32 x = GRID_X_START; x < GRID_X_START + GRID_WIDTH; x += BLOCK_SIZE) {
        DrawRectangle(dispCtrl.framePtr[dispCtrl.curFrame], x, yStart, 1, BLOCK_SIZE, dispCtrl.stride, 255, 255, 255); // Vertical grid line
    }
    DrawRectangle(dispCtrl.framePtr[dispCtrl.curFrame], GRID_X_START, yStart, GRID_WIDTH, 1, dispCtrl.stride, 255, 255, 255); // Top horizontal grid line
    DrawRectangle(dispCtrl.framePtr[dispCtrl.curFrame], GRID_X_START, yStart + BLOCK_SIZE - 1, GRID_WIDTH, 1, dispCtrl.stride, 255, 255, 255); // Bottom horizontal grid line
}


double GetFallInterval(int switch_value, double normal_fall_interval, double fast_fall_interval) {
    return (switch_value & 0x1) ? fast_fall_interval : normal_fall_interval;
}
int CanMoveHorizontal(u32 blockX, u32 blockY, int direction) {
    int colStart = (blockX - GRID_X_START) / BLOCK_SIZE;
    int rowStart = (blockY - GRID_Y_START) / BLOCK_SIZE;

    // Check for boundary and collision conditions for each shape
    if (currentShape == SHAPE_I) { // Vertical I block
        for (int i = 0; i < 4; i++) {
            int newCol = colStart + direction;
            if (newCol < 0 || newCol >= GRID_COLUMNS || grid[rowStart + i][newCol] == 1) {
                return 0; // Collision or boundary exceeded
            }
        }
    } else if (currentShape == SHAPE_O) { // O block
        for (int i = 0; i < 2; i++) {
            for (int j = 0; j < 2; j++) {
                int newCol = colStart + j + direction;
                if (newCol < 0 || newCol >= GRID_COLUMNS || grid[rowStart + i][newCol] == 1) {
                    return 0; // Collision or boundary exceeded
                }
            }
        }
    } else if (currentShape == SHAPE_T) { // T block
        // Check for horizontal bar
        for (int j = 0; j < 3; j++) {
            int newCol = colStart + j + direction;
            if (newCol < 0 || newCol >= GRID_COLUMNS || grid[rowStart][newCol] == 1) {
                return 0; // Collision or boundary exceeded
            }
        }
        // Check for vertical bar above
        int newCol = colStart + 1 + direction;
        if (newCol < 0 || newCol >= GRID_COLUMNS || grid[rowStart - 1][newCol] == 1) {
            return 0; // Collision or boundary exceeded
        }
    } else if (currentShape == SHAPE_S) {
        // Top row
        for (int j = 1; j < 3; j++) {  // Top-right and top-left
            int newCol = colStart + j + direction;
            if (newCol < 0 || newCol >= GRID_COLUMNS || grid[rowStart][newCol] == 1) {
                return 0; // Collision or boundary exceeded
            }
        }
        // Bottom row
        for (int j = 0; j < 2; j++) {  // Bottom-left and bottom-middle
            int newCol = colStart + j + direction;
            if (newCol < 0 || newCol >= GRID_COLUMNS || grid[rowStart + 1][newCol] == 1) {
                return 0; // Collision or boundary exceeded
            }
        }
    } else   if (currentShape == SHAPE_Z) {
        for (int j = 0; j < 2; j++) {
            int newCol = colStart + j + direction;
            if (newCol < 0 || newCol >= GRID_COLUMNS || grid[rowStart][newCol] == 1) {
                return 0; // Collision or boundary exceeded
            }
        }
        for (int j = 1; j < 3; j++) {
            int newCol = colStart + j + direction;
            if (newCol < 0 || newCol >= GRID_COLUMNS || grid[rowStart + 1][newCol] == 1) {
                return 0; // Collision or boundary exceeded
            }
        }

    } else if (currentShape == SHAPE_L) {
        // Check vertical bar
        for (int i = 0; i < 2; i++) {
            int newCol = colStart + direction;
            if (newCol < 0 || newCol >= GRID_COLUMNS || grid[rowStart + i][newCol] == 1) {
                return 0; // Collision detected
            }
        }
        // Check horizontal bar
        for (int j = 1; j < 3; j++) {
            int newCol = colStart + j + direction;
            if (newCol < 0 || newCol >= GRID_COLUMNS || grid[rowStart + 1][newCol] == 1) {
                return 0; // Collision detected
            }
        }
    } else if (currentShape == SHAPE_J) {
        // Check vertical bar
        for (int i = 0; i < 2; i++) {
            int newCol = colStart + 2 + direction; // Vertical bar at colStart + 2
            if (newCol < 0 || newCol >= GRID_COLUMNS || grid[rowStart + i][newCol] == 1) {
                return 0; // Collision detected
            }
        }
        // Check horizontal bar
        for (int j = 0; j < 2; j++) { // Horizontal bar from colStart to colStart + 1
            int newCol = colStart + j + direction;
            if (newCol < 0 || newCol >= GRID_COLUMNS || grid[rowStart + 1][newCol] == 1) {
                return 0; // Collision detected
            }
        }
    }



    return 1; // No collision or boundary exceeded
}


int main(void) {




    DemoInitialize();
    DemoFillDarkBlue(dispCtrl.framePtr[dispCtrl.curFrame], dispCtrl.vMode.width, dispCtrl.vMode.height, dispCtrl.stride);

    xil_printf("Press BTN2 to start the game. Use BTN0 to move right, BTN3 to move left.\r\n");

    // Initialize button GPIO
    int status = XGpio_Initialize(&BTNInst, XPAR_AXI_GPIO_BTN_DEVICE_ID);
    if (status != XST_SUCCESS) {
        xil_printf("Button GPIO Initialization Failed\r\n");
        return XST_FAILURE;
    }

    XGpio_SetDataDirection(&BTNInst, 1, 0xFF);
    // Initialize switch GPIO
     status = XGpio_Initialize(&SWInst, XPAR_AXI_GPIO_SW_DEVICE_ID);
    if (status != XST_SUCCESS) {
        xil_printf("Switch GPIO Initialization Failed\r\n");
       return XST_FAILURE;
   }
    int btn1_last_state = 0, btn0_last_state = 0, btn3_last_state = 0, btn2_last_state = 0;
    int simulationStarted = 0;
    int isFalling = 0;
    u32 blockX = GRID_X_START + (GRID_WIDTH / 2) - BLOCK_SIZE * 2;
    u32 blockY = GRID_Y_START;

    XTime last_time, current_time;
    XTime_GetTime(&last_time);
    double fall_interval = 0.3;

    xil_printf("Game ready. Press BTN2 to start.\r\n");




    while (1) {
        int btn_value = XGpio_DiscreteRead(&BTNInst, 1);
        int switch_value = XGpio_DiscreteRead(&SWInst, 1);

        // BTN2: Start the game
        if ((btn_value & 0x4) && !btn2_last_state) {
            xil_printf("Starting simulation.\r\n");
            simulationStarted = 1;
            isFalling = 1;
            blockY = GRID_Y_START;

            score = 0; // Reset score
            xil_printf("Score reset to %d\r\n", score);

            // Clear the grid and restart
            memset(grid, 0, sizeof(grid));
            DemoFillBlack(dispCtrl.framePtr[dispCtrl.curFrame], dispCtrl.vMode.width, dispCtrl.vMode.height, dispCtrl.stride);
            DrawGrid(dispCtrl.framePtr[dispCtrl.curFrame], GRID_X_START, GRID_Y_START, GRID_WIDTH, GRID_HEIGHT, dispCtrl.stride, BLOCK_SIZE);
        }

        btn2_last_state = btn_value & 0x4;

        if (!simulationStarted) continue;

        // Check for Game Over
        for (int col = 0; col < GRID_COLUMNS; col++) {
            if (grid[0][col] == 1) { // Top row occupied
                xil_printf("Game Over! Press BTN2 to restart.\r\n");
                simulationStarted = 0; // Stop the simulation
                isFalling = 0;         // Disable falling
                break;
            }
        }

        if (!simulationStarted) continue;

        // Clear the trail of the previous position
        if (isFalling) {
            ClearBlockTrail(blockX, blockY);
        }
        DrawScoreBox(dispCtrl.framePtr[dispCtrl.curFrame], SCORE_BOX_X, SCORE_BOX_Y, SCORE_BOX_WIDTH, SCORE_BOX_HEIGHT, dispCtrl.stride);

        if (switch_value & 0x1) {
            current_fall_interval = fast_fall_interval; // Fast fall when SW0 is ON
            xil_printf("SW0 is ON! Block falling faster.\r\n");
        } else {
            current_fall_interval = normal_fall_interval; // Normal fall otherwise
        }

        // Handle movement (right, left)
        if ((btn_value & 0x1) && !btn0_last_state) { // Move Right
            if (CanMoveHorizontal(blockX, blockY, 1)) { // Check if moving right is valid
                blockX += BLOCK_SIZE;
            }
        }
        btn0_last_state = btn_value & 0x1;

        if ((btn_value & 0x8) && !btn3_last_state) { // Move Left
            if (CanMoveHorizontal(blockX, blockY, -1)) { // Check if moving left is valid
                blockX -= BLOCK_SIZE;
            }
        }
        btn3_last_state = btn_value & 0x8;

        // Check falling
        XTime_GetTime(&current_time);
        double elapsed_time = ((double)(current_time - last_time)) / COUNTS_PER_SECOND;

        if (elapsed_time >= current_fall_interval) {
            last_time = current_time;

            if (CanMoveDown(blockX, blockY)) {
                blockY += BLOCK_SIZE; // Move the block down
            } else {
                isFalling = 0; // The block has landed
                xil_printf("Block landed. Making it solid.\r\n");

                // Mark the block in the grid
                MarkBlockOnGrid(blockX, blockY);

                // Render the landed block in its final position
                MarkLandedBlocks(blockX, blockY);

                // Check and clear full rows
                ClearFullRows();

                // Spawn the next block
                SpawnNextBlock(&blockX, &blockY, &currentShape);

                isFalling = 1; // Enable falling for the new block
            }
        }

        // Draw the active block
        if (isFalling) {
            // Render the active block at the current position
            DrawActiveBlock(blockX, blockY);
            Xil_DCacheFlushRange((unsigned int)dispCtrl.framePtr[dispCtrl.curFrame], dispCtrl.vMode.height * dispCtrl.stride);
        }


        // Delay for smooth animation
        usleep(5000);
    }


}

void DrawShapeO(u8 *frame, u32 xStart, u32 yStart, u32 blockSize, u32 stride, u8 red, u8 green, u8 blue) {
    // Top-left block
    DrawBlock(frame, xStart, yStart, blockSize, stride, red, green, blue);
    // Top-right block
    DrawBlock(frame, xStart + blockSize, yStart, blockSize, stride, red, green, blue);
    // Bottom-left block
    DrawBlock(frame, xStart, yStart + blockSize, blockSize, stride, red, green, blue);
    // Bottom-right block
    DrawBlock(frame, xStart + blockSize, yStart + blockSize, blockSize, stride, red, green, blue);
}

// Interrupt Handler for mode switching and actions
void BTN_Intr_Handler(void *InstancePtr) {
    // Read the button and switch values
    int btn_value = XGpio_DiscreteRead(&BTNInst, 1);
    int switch_value = XGpio_DiscreteRead(&SWInst, 1);

    // Check if BTN1 (bit 0) is pressed
    if (btn_value & 0x1) {
    DemoFillWhite(dispCtrl.framePtr[dispCtrl.curFrame], dispCtrl.vMode.width, dispCtrl.vMode.height, dispCtrl.stride);

    }

    // Check if SW0 (bit 0) is ON
    if (switch_value & 0x1) {
        xil_printf("SW0 is ON!\r\n");
    }
}



void FallShape(u8 *frame, u32 width, u32 height, u32 stride,
               void (*DrawShape)(u8*, u32, u32, u32, u32, u8, u8, u8),
               u32 xStart, u32 blockSize, u8 red, u8 green, u8 blue) {
    u32 yPosition = 0; // Start from the top

    while (yPosition + blockSize * 4 < height) { // Ensure it doesn't fall off screen
        // Clear screen
        DemoFillBlack(frame, width, height, stride);

        // Draw the shape at the current position
        DrawShape(frame, xStart, yPosition, blockSize, stride, red, green, blue);

        // Update the y-position
        yPosition += blockSize;

        // Delay for the falling animation
        usleep(200000); // Adjust for speed (200ms)
    }
}


void DrawGrid(u8 *frame, u32 xStart, u32 yStart, u32 width, u32 height, u32 stride, u32 blockSize) {
    // Draw vertical grid lines
    for (u32 x = xStart; x <= xStart + width; x += blockSize) {
        DrawRectangle(frame, x, yStart, 1, height, stride, 200, 200, 200); // Light gray lines
    }

    // Draw horizontal grid lines
    for (u32 y = yStart; y <= yStart + height; y += blockSize) {
        DrawRectangle(frame, xStart, y, width, 1, stride, 200, 200, 200); // Light gray lines
    }
}

void DrawLetterOptimized(u8 *frame, u32 xStart, u32 yStart, u32 stride, char letter, u8 red, u8 green, u8 blue) {
    u32 blockSize = 1; // Smaller size to fit inside the score box
    switch (letter) {
        case 'S':
            // Top bar
            DrawRectangle(frame, xStart + blockSize, yStart, 3 * blockSize, blockSize, stride, red, green, blue);
            // Top curve
            DrawRectangle(frame, xStart, yStart + blockSize, blockSize, blockSize, stride, red, green, blue);
            DrawRectangle(frame, xStart + blockSize, yStart + 2 * blockSize, 3 * blockSize, blockSize, stride, red, green, blue);
            // Bottom curve
            DrawRectangle(frame, xStart + 3 * blockSize, yStart + 3 * blockSize, blockSize, blockSize, stride, red, green, blue);
            DrawRectangle(frame, xStart, yStart + 4 * blockSize, 3 * blockSize, blockSize, stride, red, green, blue);
            break;
        case 'C':
            // Top bar
            DrawRectangle(frame, xStart + blockSize, yStart, 3 * blockSize, blockSize, stride, red, green, blue);
            // Left vertical bar
            DrawRectangle(frame, xStart, yStart + blockSize, blockSize, 3 * blockSize, stride, red, green, blue);
            // Bottom bar
            DrawRectangle(frame, xStart + blockSize, yStart + 4 * blockSize, 3 * blockSize, blockSize, stride, red, green, blue);
            break;
        case 'O':
            // Top bar
            DrawRectangle(frame, xStart + blockSize, yStart, 3 * blockSize, blockSize, stride, red, green, blue);
            // Left vertical bar
            DrawRectangle(frame, xStart, yStart + blockSize, blockSize, 3 * blockSize, stride, red, green, blue);
            // Right vertical bar
            DrawRectangle(frame, xStart + 4 * blockSize, yStart + blockSize, blockSize, 3 * blockSize, stride, red, green, blue);
            // Bottom bar
            DrawRectangle(frame, xStart + blockSize, yStart + 4 * blockSize, 3 * blockSize, blockSize, stride, red, green, blue);
            break;
        case 'R':
            // Vertical bar
            DrawRectangle(frame, xStart, yStart, blockSize, 5 * blockSize, stride, red, green, blue);
            // Top bar
            DrawRectangle(frame, xStart + blockSize, yStart, 3 * blockSize, blockSize, stride, red, green, blue);
            // Middle bar
            DrawRectangle(frame, xStart + blockSize, yStart + 2 * blockSize, 3 * blockSize, blockSize, stride, red, green, blue);
            // Diagonal leg
            DrawRectangle(frame, xStart + 2 * blockSize, yStart + 3 * blockSize, blockSize, blockSize, stride, red, green, blue);
            DrawRectangle(frame, xStart + 3 * blockSize, yStart + 4 * blockSize, blockSize, blockSize, stride, red, green, blue);
            break;
        case 'E':
            // Vertical bar
            DrawRectangle(frame, xStart, yStart, blockSize, 5 * blockSize, stride, red, green, blue);
            // Top bar
            DrawRectangle(frame, xStart + blockSize, yStart, 3 * blockSize, blockSize, stride, red, green, blue);
            // Middle bar
            DrawRectangle(frame, xStart + blockSize, yStart + 2 * blockSize, 2 * blockSize, blockSize, stride, red, green, blue);
            // Bottom bar
            DrawRectangle(frame, xStart + blockSize, yStart + 4 * blockSize, 3 * blockSize, blockSize, stride, red, green, blue);
            break;
        case ' ':
            // Space character: Do nothing, just leave a gap
            break;
        case '0' ... '9': // Digits
            DrawDigit(frame, xStart, yStart, stride, letter - '0', red, green, blue);
            break;
        default:
            break;
    }
}
void DrawDigit(u8 *frame, u32 xStart, u32 yStart, u32 stride, int digit, u8 red, u8 green, u8 blue) {
    u32 blockSize = 1; // Small block size for digits
    switch (digit) {
        case 0:
            DrawRectangle(frame, xStart, yStart, 4 * blockSize, blockSize, stride, red, green, blue); // Top bar
            DrawRectangle(frame, xStart, yStart + blockSize, blockSize, 5 * blockSize, stride, red, green, blue); // Left bar
            DrawRectangle(frame, xStart + 3 * blockSize, yStart + blockSize, blockSize, 5 * blockSize, stride, red, green, blue); // Right bar
            DrawRectangle(frame, xStart, yStart + 6 * blockSize, 4 * blockSize, blockSize, stride, red, green, blue); // Bottom bar
            break;
        case 1:
            DrawRectangle(frame, xStart + 3 * blockSize, yStart, blockSize, 7 * blockSize, stride, red, green, blue); // Single bar
            break;
        case 2:
            DrawRectangle(frame, xStart, yStart, 4 * blockSize, blockSize, stride, red, green, blue); // Top bar
            DrawRectangle(frame, xStart + 3 * blockSize, yStart + blockSize, blockSize, 2 * blockSize, stride, red, green, blue); // Upper right
            DrawRectangle(frame, xStart, yStart + 3 * blockSize, 4 * blockSize, blockSize, stride, red, green, blue); // Middle bar
            DrawRectangle(frame, xStart, yStart + 4 * blockSize, blockSize, 2 * blockSize, stride, red, green, blue); // Lower left
            DrawRectangle(frame, xStart, yStart + 6 * blockSize, 4 * blockSize, blockSize, stride, red, green, blue); // Bottom bar
            break;
        case 3:
            DrawRectangle(frame, xStart, yStart, 4 * blockSize, blockSize, stride, red, green, blue); // Top bar
            DrawRectangle(frame, xStart + 3 * blockSize, yStart + blockSize, blockSize, 2 * blockSize, stride, red, green, blue); // Upper right
            DrawRectangle(frame, xStart, yStart + 3 * blockSize, 4 * blockSize, blockSize, stride, red, green, blue); // Middle bar
            DrawRectangle(frame, xStart + 3 * blockSize, yStart + 4 * blockSize, blockSize, 2 * blockSize, stride, red, green, blue); // Lower right
            DrawRectangle(frame, xStart, yStart + 6 * blockSize, 4 * blockSize, blockSize, stride, red, green, blue); // Bottom bar
            break;
        case 4:
            DrawRectangle(frame, xStart, yStart, blockSize, 3 * blockSize, stride, red, green, blue); // Upper left
            DrawRectangle(frame, xStart, yStart + 3 * blockSize, 4 * blockSize, blockSize, stride, red, green, blue); // Middle bar
            DrawRectangle(frame, xStart + 3 * blockSize, yStart, blockSize, 7 * blockSize, stride, red, green, blue); // Right bar
            break;
        case 5:
            DrawRectangle(frame, xStart, yStart, 4 * blockSize, blockSize, stride, red, green, blue); // Top bar
            DrawRectangle(frame, xStart, yStart + blockSize, blockSize, 2 * blockSize, stride, red, green, blue); // Upper left
            DrawRectangle(frame, xStart, yStart + 3 * blockSize, 4 * blockSize, blockSize, stride, red, green, blue); // Middle bar
            DrawRectangle(frame, xStart + 3 * blockSize, yStart + 4 * blockSize, blockSize, 2 * blockSize, stride, red, green, blue); // Lower right
            DrawRectangle(frame, xStart, yStart + 6 * blockSize, 4 * blockSize, blockSize, stride, red, green, blue); // Bottom bar
            break;
        case 6:
            DrawRectangle(frame, xStart, yStart, 4 * blockSize, blockSize, stride, red, green, blue); // Top bar
            DrawRectangle(frame, xStart, yStart + blockSize, blockSize, 5 * blockSize, stride, red, green, blue); // Left bar
            DrawRectangle(frame, xStart, yStart + 3 * blockSize, 4 * blockSize, blockSize, stride, red, green, blue); // Middle bar
            DrawRectangle(frame, xStart + 3 * blockSize, yStart + 4 * blockSize, blockSize, 2 * blockSize, stride, red, green, blue); // Lower right
            DrawRectangle(frame, xStart, yStart + 6 * blockSize, 4 * blockSize, blockSize, stride, red, green, blue); // Bottom bar
            break;
        case 7:
            DrawRectangle(frame, xStart, yStart, 4 * blockSize, blockSize, stride, red, green, blue); // Top bar
            DrawRectangle(frame, xStart + 3 * blockSize, yStart + blockSize, blockSize, 6 * blockSize, stride, red, green, blue); // Right bar
            break;
        case 8:
            DrawRectangle(frame, xStart, yStart, 4 * blockSize, blockSize, stride, red, green, blue); // Top bar
            DrawRectangle(frame, xStart, yStart + blockSize, blockSize, 5 * blockSize, stride, red, green, blue); // Left bar
            DrawRectangle(frame, xStart + 3 * blockSize, yStart + blockSize, blockSize, 5 * blockSize, stride, red, green, blue); // Right bar
            DrawRectangle(frame, xStart, yStart + 3 * blockSize, 4 * blockSize, blockSize, stride, red, green, blue); // Middle bar
            DrawRectangle(frame, xStart, yStart + 6 * blockSize, 4 * blockSize, blockSize, stride, red, green, blue); // Bottom bar
            break;
        case 9:
            DrawRectangle(frame, xStart, yStart, 4 * blockSize, blockSize, stride, red, green, blue); // Top bar
            DrawRectangle(frame, xStart, yStart + blockSize, blockSize, 2 * blockSize, stride, red, green, blue); // Upper left
            DrawRectangle(frame, xStart + 3 * blockSize, yStart + blockSize, blockSize, 5 * blockSize, stride, red, green, blue); // Right bar
            DrawRectangle(frame, xStart, yStart + 3 * blockSize, 4 * blockSize, blockSize, stride, red, green, blue); // Middle bar
            DrawRectangle(frame, xStart, yStart + 6 * blockSize, 4 * blockSize, blockSize, stride, red, green, blue); // Bottom bar
            break;
    }
}
void DrawNumber(u8 *frame, u32 xStart, u32 yStart, const char *number, u32 stride, u8 red, u8 green, u8 blue) {
    u32 blockSize = 2; // Small block size for digits
    while (*number) {
        if (isdigit(*number)) {
            // Draw the digit and move the xStart closer
            DrawDigit(frame, xStart, yStart, stride, *number - '0', red, green, blue);
            xStart += 5 * blockSize; // Reduced spacing
        }
        number++;
    }
}
void DrawText(u8 *frame, u32 xStart, u32 yStart, const char *text, u32 stride, u8 red, u8 green, u8 blue) {
    u32 blockSize = 2; // Small block size for letters
    while (*text) {
        if (isalpha(*text)) {
            // Draw the letter and move the xStart closer
            DrawLetterOptimized(frame, xStart, yStart, stride, *text, red, green, blue);
            xStart += 6 * blockSize; // Reduced spacing
        }
        text++;
    }
}




void DrawScoreBox(u8 *frame, u32 xStart, u32 yStart, u32 width, u32 height, u32 stride) {
    char scoreText[16];
    u32 textX = xStart + 10; // Adjust as needed for proper alignment
    u32 textY = yStart + 20;

    // Outer border
    DrawRectangle(frame, xStart, yStart, width, height, stride, 255, 255, 255); // White border

    // Inside background
    DrawRectangle(frame, xStart + 5, yStart + 5, width - 10, height - 10, stride, 0, 0, 0); // Black fill

    // Display the text "SCORE"
    char label[] = "SCORE";
    for (int i = 0; label[i] != '\0'; i++) {
        DrawLetterOptimized(frame, textX, textY, stride, label[i], 255, 255, 255);
        textX += 8; // Adjust spacing
    }

    // Reset position for the score digits
    textX = xStart + 10;
    textY += 20;

    // Convert the score into digits and draw each digit
    int tempScore = score;
    char scoreDigits[6];
    snprintf(scoreDigits, sizeof(scoreDigits), "%d", tempScore);

    for (int i = 0; scoreDigits[i] != '\0'; i++) {
        DrawDigit(frame, textX, textY, stride, scoreDigits[i] - '0', 255, 255, 255);
        textX += 10; // Adjust spacing
    }

    // Flush the cache to ensure changes are reflected in memory
    Xil_DCacheFlushRange((unsigned int)frame, stride * height);
}


void DrawNextBox(u8 *frame, u32 xStart, u32 yStart, u32 width, u32 height, u32 stride) {
    // Outer border
    DrawRectangle(frame, xStart, yStart, width, height, stride, 255, 255, 255); // White border

    // Inside background
    DrawRectangle(frame, xStart + 5, yStart + 5, width - 10, height - 10, stride, 0, 0, 0); // Black fill
}


void DrawShapeI(u8 *frame, u32 xStart, u32 yStart, u32 blockSize, u32 stride, u8 red, u8 green, u8 blue) {
    // Draw a vertical bar with 4 blocks
    for (int i = 0; i < 4; i++) {
        DrawBlock(frame, xStart, yStart + i * blockSize, blockSize, stride, red, green, blue);
    }
}

void DrawShapeT(u8 *frame, u32 xStart, u32 yStart, u32 blockSize, u32 stride, u8 red, u8 green, u8 blue) {
    // Draw vertical bar (block above the horizontal bar)
    DrawBlock(frame, xStart + blockSize, yStart - blockSize, blockSize, stride, red, green, blue);

    // Draw horizontal bar
    DrawBlock(frame, xStart, yStart, blockSize, stride, red, green, blue);
    DrawBlock(frame, xStart + blockSize, yStart, blockSize, stride, red, green, blue);
    DrawBlock(frame, xStart + 2 * blockSize, yStart, blockSize, stride, red, green, blue);
}


void DrawShapeL(u8 *frame, u32 xStart, u32 yStart, u32 blockSize, u32 stride, u8 red, u8 green, u8 blue) {
    // Bottom horizontal bar (3 blocks to the right)
    for (int i = 0; i < 3; i++) {
        DrawBlock(frame, xStart + i * blockSize, yStart + blockSize, blockSize, stride, red, green, blue);
    }
    // Vertical bar (2 blocks)
    DrawBlock(frame, xStart, yStart, blockSize, stride, red, green, blue);
    DrawBlock(frame, xStart, yStart + blockSize, blockSize, stride, red, green, blue);
}

void DrawShapeJ(u8 *frame, u32 xStart, u32 yStart, u32 blockSize, u32 stride, u8 red, u8 green, u8 blue) {
    // Draw vertical bar (2 blocks)
    DrawBlock(frame, xStart + 2 * blockSize, yStart, blockSize, stride, red, green, blue); // Top vertical block
    DrawBlock(frame, xStart + 2 * blockSize, yStart + blockSize, blockSize, stride, red, green, blue); // Bottom vertical block

    // Draw horizontal bar (3 blocks to the left)
    for (int i = 0; i < 3; i++) {
        DrawBlock(frame, xStart + i * blockSize, yStart + blockSize, blockSize, stride, red, green, blue);
    }
}


void DrawShapeS(u8 *frame, u32 xStart, u32 yStart, u32 blockSize, u32 stride, u8 red, u8 green, u8 blue) {
    // Top part
    DrawBlock(frame, xStart + blockSize, yStart, blockSize, stride, red, green, blue);
    DrawBlock(frame, xStart + 2 * blockSize, yStart, blockSize, stride, red, green, blue);
    // Bottom part
    DrawBlock(frame, xStart, yStart + blockSize, blockSize, stride, red, green, blue);
    DrawBlock(frame, xStart + blockSize, yStart + blockSize, blockSize, stride, red, green, blue);
}

void DrawShapeZ(u8 *frame, u32 xStart, u32 yStart, u32 blockSize, u32 stride, u8 red, u8 green, u8 blue) {
    // Top part
    DrawBlock(frame, xStart, yStart, blockSize, stride, red, green, blue);
    DrawBlock(frame, xStart + blockSize, yStart, blockSize, stride, red, green, blue);
    // Bottom part
    DrawBlock(frame, xStart + blockSize, yStart + blockSize, blockSize, stride, red, green, blue);
    DrawBlock(frame, xStart + 2 * blockSize, yStart + blockSize, blockSize, stride, red, green, blue);
}
